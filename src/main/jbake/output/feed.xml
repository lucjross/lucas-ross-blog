<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lucas's Programming Blog</title>
    <link>http://lucas-ross.com</link>
    <atom:link href="http://lucas-ross.com/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <description>A Java-centric programming blog</description>
    <language>en-US</language>
    <pubDate>Sun, 8 Jan 2017 17:31:31 -0600</pubDate>
    <item>
      <title>Does it matter whether I return an empty collection or a null one?</title>
      <link>blog/2017/01-01.html</link>
      <description>
&lt;p&gt;This is kind of a philosophical question. Is code A any better or worse than code B?&lt;/p&gt;
&lt;div class=&quot;panel panel-default&quot;&gt;
    &lt;div class=&quot;panel-heading&quot;&gt;A&lt;/div&gt;
    &lt;div class=&quot;panel-body&quot;&gt;&lt;pre class=&quot;brush: java&quot;&gt;
 Collection&amp;lt;String&amp;gt; words() {
     Collection&amp;lt;Sentence&amp;gt; sentences = dao.getSentences();
     if (sentences != null) {
         return sentences.stream().flatMap(sentence -&amp;gt; sentence.getWords().stream())
             .collect(Collectors.toList());
     }
     else {
         return Collections.emptyList();
     }
 }
    &lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;panel panel-default&quot;&gt;
    &lt;div class=&quot;panel-heading&quot;&gt;B&lt;/div&gt;
    &lt;div class=&quot;panel-body&quot;&gt;&lt;pre class=&quot;brush: java&quot;&gt;
 Optional&amp;lt;Collection&amp;lt;String&amp;gt;&amp;gt; words() {
     Collection&amp;lt;Sentence&amp;gt; sentences = dao.getSentences();
     if (sentences == null) {
         return Optional.empty();
     }
     else {
         return Optional.of(
             sentences.stream().flatMap(sentence -&amp;gt; sentence.getWords().stream())
                 .collect(Collectors.toList()));
     }
 }
    &lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;In the absence of documentation, here is how I would interpret two methods like those.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
    &lt;tr&gt;
        &lt;th&gt;Method&lt;/th&gt;
        &lt;th&gt;What the method is expected to do&lt;/th&gt;
        &lt;th&gt;What the method actually does&lt;/th&gt;
        &lt;th&gt;What you get&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;A&lt;/td&gt;
        &lt;td&gt;Obtain some X and give you some Y based upon those X&lt;/td&gt;
        &lt;td&gt;
            &lt;p&gt;If unable to obtain X, we'll just pretend that we did.&lt;/p&gt;
            &lt;p&gt;Thereby, we can pretend that we know what Y exists, and arbitrarily provide some Y (zero of them, perhaps).
                No one will ever know the difference!&lt;/p&gt;
        &lt;/td&gt;
        &lt;td&gt;Some (zero) Y&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;B&lt;/td&gt;
        &lt;td&gt;Obtain some X and give you some Y based upon those X&lt;/td&gt;
        &lt;td&gt;
            &lt;p&gt;If unable to obtain X, then we don't know what X exists. Some other source may know, but we don't.&lt;/p&gt;
            &lt;p&gt;Therefore we don't know what Y exists either. We'll admit that we don't know, which may be a helpful signal to the user.&lt;/p&gt;
        &lt;/td&gt;
        &lt;td&gt;null or &lt;code&gt;Optional.empty()&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;You may notice that I'm biased on this issue, but either way, there is a difference.
    For a given scenario, how do you decide whether this matters?
    Basically, how do you know whether it's going to affect a user's (another developer's) experience?
    A few factors may be considered:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Is the method public or protected? If so, there's no telling how an imprecise return value can affect future development,
        so a developer should probably err on the side of returning (or throwing) an indicator of &quot;missing information&quot; as necessary.&lt;/li&gt;
    &lt;li&gt;Is the method adapting to a legacy or third-party API? If so, there might be no choice but to accept &quot;null&quot; to mean
        &quot;empty&quot; or vice-versa.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In any case, is it really necessary to force developers to ask these questions and have to solve mysteries about
    what a function result is supposed to mean? Providing a clear contract can make this a non-issue:&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
 /**
  * @return  a Collection containing all the Words in all the Sentences. If the Sentences are unknown,
  *          then an empty list will be returned.
  */
 @NotNull
 public Collection&amp;lt;String&amp;gt; words() { ...
&lt;/pre&gt;

</description>
      <pubDate>Sun, 1 Jan 2017 00:00:00 -0600</pubDate>
      <guid isPermaLink="false">blog/2017/01-01.html</guid>
    </item>
    <item>
      <title>Improved Hot-Swapping with DCEVM + HotswapAgent</title>
      <link>blog/2016/12-30.html</link>
      <description>
&lt;p&gt;Maybe you've seen this sort of error before:&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;img/Screen Shot 2016-12-14 at 7.06.52 PM.jpeg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;This can happen when you're running an application in IntelliJ IDEA and you select &lt;i&gt;Run&lt;/i&gt; &gt; &lt;i&gt;Reload Changed Classes&lt;/i&gt;.
    As the red pop-up suggests, the VM was unable to hot-swap a class change,
    which could have involved any of the following:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Changing a method signature&lt;/li&gt;
    &lt;li&gt;Adding or removing a method or field&lt;/li&gt;
    &lt;li&gt;Changing the superclass of a class&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(See: &lt;a href=&quot;http://arhipov.blogspot.com/2016/02/hotswap-vs-hot-deploy_12.html&quot;&gt;HotSwap vs hot deploy&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;That leaves only changes to statements within method bodies,
    which indeed is the only hot-swap capability provided by the vanilla runtime.
    There's a pretty easy way to enable hot-swapping for all these cases,
    except the case of changing the superclass.
    &lt;a href=&quot;https://github.com/HotswapProjects/HotswapAgent&quot;&gt;HotswapAgent&lt;/a&gt; is a java agent that provides this capability,
    using a HotSpot JRE that is patched with &lt;a href=&quot;https://github.com/dcevm/dcevm&quot;&gt;Dynamic Code Evolution VM&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;well&quot;&gt;The modifications described here are not suitable for any kind of deployment
    as they introduce instability to the runtime environment.
    It's designed only for improving productivity during development.&lt;/div&gt;

&lt;p&gt;To try it out, I simply followed the directions on the HotswapAgent readme.
    I patched a local Oracle 8u92 JDK with DCEVM using their installer jar.
    Then I somewhat arbitrarily chose a web server app to try it out with.
    The next step was creating the Run/Debug Configuration:&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;img/Screen Shot 2016-12-14 at 8.30.04 PM.jpeg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I started the server and saw in the logs that the agent was active:&lt;/p&gt;
&lt;blockquote&gt;
    HOTSWAP AGENT: 16:16:34.809 INFO (org.hotswap.agent.HotswapAgent) - Loading Hotswap agent {0.4.0-SNAPSHOT} - unlimited runtime class redefinition.&lt;br/&gt;
    HOTSWAP AGENT: 16:16:35.612 INFO (org.hotswap.agent.config.PluginRegistry) - Discovered plugins: [Hotswapper, WatchResources, AnonymousClassPatch, ClassInitPlugin, Hibernate, Hibernate3JPA, Hibernate3, Spring, Jersey1, Jersey2, Jetty, Tomcat, ZK, Logback, Log4j2, MyFaces, Mojarra, Seam, ELResolver, WildFlyELResolver, OsgiEquinox, Proxy, WebObjects, Weld, JBossModules, ResteasyRegistry, Gae, Deltaspike, JavaBeans]
&lt;/blockquote&gt;

&lt;p&gt;While it was still running, I added a method to a class (one that had already been loaded by a ClassLoader),
    and hit &lt;i&gt;Reload Changed Classes&lt;/i&gt;. Good news:&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;img/Screen Shot 2016-12-14 at 7.12.23 PM.jpeg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;This saved me about thirty seconds that I would have had to spend waiting for a server restart.&lt;/p&gt;
</description>
      <pubDate>Fri, 30 Dec 2016 00:00:00 -0600</pubDate>
      <guid isPermaLink="false">blog/2016/12-30.html</guid>
    </item>
    <item>
      <title>Override some methods and delegate others without reimplementing everything</title>
      <link>blog/2016/12-15.html</link>
      <description>
&lt;p&gt;Given this class:&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
 interface Things {
 
     String w();
     long x();
     int y();
     Class&amp;lt;?&amp;gt; z();
 }
&lt;/pre&gt;

&lt;p&gt;Suppose you've gotten ahold of an &lt;i&gt;instance&lt;/i&gt; of some implementation of this interface.
    You happen to know that that implementation of Things#y does something really awful,
    and you're stuck with that implementation for now because it comes from a library or framework.
    So, you could create a wrapper for that instance like thus:&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
 class ThingsWrapper implements Things {
     
     private final Things things;
     
     ThingsWrapper(final Things things) {
         this.things = things;
     }
  
     @Override String w() { return things.w(); }
  
     @Override long x() { return things.x(); }
  
     @Override int y() {
         // the interface says i'm supposed to get a ratio but the impl provides a percentage
         return things.y() / 100;
     }
  
 	@Override Class&amp;lt;?&amp;gt; z() { return things.z(); }
 }
&lt;/pre&gt;
&lt;p&gt;If there are 50 methods on this class, then, yep, we'll have to override 49 methods with nothing but delegations.&lt;/p&gt;

&lt;h2&gt;Solution 1: Dynamic Proxy&lt;/h2&gt;
&lt;p&gt;A much lazier way to do this is with dynamic proxying. There is a simple way to do this with the JDK:&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
 Things wrapped0 = (Things) Proxy.newProxyInstance(
     Things.class.getClassLoader(),
     new Class&amp;lt;?&amp;gt;[] { Things.class },
     (proxy, method, args) -&amp;gt; {
 
         if (&quot;y&quot;.equals(method.getName())) {
             return originalThings.y() / 100;
         } else {
             return method.invoke(originalThings, args);
         }
     });
&lt;/pre&gt;
&lt;p&gt;This way we only have to override (or really, tell a proxy factory to do something special with)
    methods that we need overridden and don't have to bother with others.&lt;/p&gt;
&lt;p&gt;However, this is really brittle because of the use of a literal String &quot;y&quot; to compare a method name.
    It's also incorrect, strictly speaking, since parameter types also must be compared.
    I prefer another technique illustrated in another blog post. Some AspectJ advice is defined:&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
 @Aspect
 class ThingsAspect {
 
     @Around(&quot;execution(int com.example.Things.y())&quot;)
     Object aroundY(ProceedingJoinPoint pjp) throws Throwable {
 		// the interface says i'm supposed to get a ratio but the impl provides a percentage
         return (int) pjp.proceed(pjp.getArgs()) / 100;
     }
 }
&lt;/pre&gt;
&lt;p&gt;Then, we can throw our instance into an AspectJ proxy factory and get a wrapper instance out of it.&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
 AspectJProxyFactory aspectJProxyFactory = new AspectJProxyFactory();
 aspectJProxyFactory.setTarget(originalThings);
 aspectJProxyFactory.addAspect(ThingsAspect.class);
 Things wrapped = aspectJProxyFactory.getProxy();
 
 Assert.assertEquals(originalThings.y() / 100, wrapped.y());
&lt;/pre&gt;
&lt;p&gt;In this screenshot you can see how IntelliJ IDEA provides syntax highlighting
    and navigation markers for well-formed Aspects.&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;img/image2016-12-12 14-29-33.jpeg&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;well&quot;&gt;None of these dynamic proxying tools can extend &lt;code&gt;final&lt;/code&gt; classes (anything in &lt;code&gt;java.lang&lt;/code&gt;).&lt;/div&gt;

&lt;h2&gt;Solution 2: @lombok.experimental.Delegate&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://projectlombok.org/features/experimental/Delegate.html&quot;&gt;@Delegate&lt;/a&gt;
    is in the lombok &quot;experimental&quot; package, so it may go away in the future.
    It's a less flexible construct, but will be slightly more performant since proxying isn't involved.
    The &lt;a href=&quot;https://plugins.jetbrains.com/idea/plugin/6317-lombok-plugin&quot;&gt;IntelliJ lombok plugin&lt;/a&gt; does support this.&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
 class ThingsWrapper implements Things {
  
     @Delegate(excludes = DelegateExcludes.class)
     private final Things things;
  
     private interface DelegateExcludes {
         int y();
     }
  
     ThingsWrapper(final Things things) {
         this.things = things;
     }
  
     @Override
     public int y() {
         // the interface says i'm supposed to get a ratio but the impl provides a percentage
         return things.y() / 100;
     }
 }
&lt;/pre&gt;

</description>
      <pubDate>Thu, 15 Dec 2016 00:00:00 -0600</pubDate>
      <guid isPermaLink="false">blog/2016/12-15.html</guid>
    </item>
    <item>
      <title>IntelliJ IDEA | Replace (migrate) all usages of a class with another</title>
      <link>blog/2016/12-01.html</link>
      <description>
&lt;p&gt;This applies to IntelliJ IDEA 2016.3. For example, to switch from &lt;code&gt;javax.validation.constraints.NotNull&lt;/code&gt;
    to &lt;code&gt;lombok.NonNull&lt;/code&gt;:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;Go to &lt;i&gt;Refactor&lt;/i&gt; &gt; &lt;i&gt;Migrate...&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;In &lt;i&gt;Package and Class Migration&lt;/i&gt; window, click &lt;i&gt;New...&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;In &lt;i&gt;Edit Migration Map&lt;/i&gt;, enter a name, e.g. &quot;javax notnull -&gt; lombok nonnull&quot;&lt;/li&gt;
    &lt;li&gt;Click &lt;i&gt;Add&lt;/i&gt; (+)&lt;/li&gt;
    &lt;li&gt;Select &lt;i&gt;Class&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;Enter old name (&quot;javax.validation.constraints.NotNull&quot;)&lt;/li&gt;
    &lt;li&gt;Enter new name (&quot;lombok.NonNull&quot;)&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;OK&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;Run&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;In &lt;i&gt;Refactoring Preview&lt;/i&gt;, verify the old class was found and click &lt;i&gt;Do Refactor&lt;/i&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      <pubDate>Thu, 1 Dec 2016 00:00:00 -0600</pubDate>
      <guid isPermaLink="false">blog/2016/12-01.html</guid>
    </item>
    <item>
      <title>Unit Testing | RunWith anything and get Spring context too</title>
      <link>blog/2016/11-15.html</link>
      <description>
&lt;p&gt;If you want to write a test using the &lt;a href=&quot;https://github.com/mockito/mockito/blob/master/src/main/java/org/mockito/junit/MockitoJUnitRunner.java&quot;&gt;Mockito class runner&lt;/a&gt;
    or the &lt;a href=&quot;https://github.com/junit-team/junit4/blob/master/src/main/java/org/junit/runners/Parameterized.java&quot;&gt;JUnit Parameterized runner&lt;/a&gt;
    or any other runner,
    you can't use the Spring class runner at the same time.
    Previously, that made it tricky to get Spring application context in conjunction with Mockito
    or advanced JUnit features.
    Spring 4.2 gives us &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/junit4/rules/SpringClassRule.html&quot;&gt;JUnit TestRules that enable Spring context&lt;/a&gt;
    without a Spring test runner. For example:&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
 @RunWith(Parameterized.class)
 @ContextConfiguration(classes = { SomeSpringConfiguration.class })
 public class SpringClassRuleTest {

     // these in conjunction are equivalent to @RunWith(SpringJUnit4ClassRunner.class)
     @ClassRule public static final SpringClassRule SPRING_CLASS_RULE = new SpringClassRule();
     @Rule public final SpringMethodRule springMethodRule = new SpringMethodRule();

     @Autowired private Random random;

     @Parameterized.Parameters
     public static Object[] bounds() {
         return new Object[] { 2, 4, 8, 16, 32 };
     }

     @Parameterized.Parameter
     public int bound;

     @Test
     public void testRandom() {
         int i = random.nextInt(bound);
         Assert.assertTrue(i &lt; bound);
     }
 }
&lt;/pre&gt;
</description>
      <pubDate>Tue, 15 Nov 2016 00:00:00 -0600</pubDate>
      <guid isPermaLink="false">blog/2016/11-15.html</guid>
    </item>
    <item>
      <title>Lucas's Compendium of Odd Java Things | Volume 5: justjvmperformancethings</title>
      <link>blog/2016/11-01.html</link>
      <description>
&lt;p&gt;In this blog I'll share some cool discoveries made by folks in the Java performance programming community
    (and subsequently, myself).
    These are issues that are produced by harmless-looking Java code. I'll try to add to this as I find more.&lt;/p&gt;

&lt;h2&gt;False Sharing&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;i&gt;&lt;a href=&quot;http://mechanical-sympathy.blogspot.com/2011/07/false-sharing.html&quot;&gt;False Sharing&lt;/a&gt;&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;&lt;a href=&quot;http://robsjava.blogspot.com/2014/03/what-is-false-sharing.html&quot;&gt;What is @Contended and False Sharing?&lt;/a&gt;&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When multiple threads access one or more variables that share a single block of memory
    (in this case, variables in an array that will end up sharing an L3 cache line),
    write contention occurs, which turns the cache into a performance bottleneck and
    dramatically diminishes performance. I tried this myself with the recent Oracle JDK 8u111
    on an Intel machine. Using the program from &lt;a href=&quot;http://mechanical-sympathy.blogspot.com/2011/08/false-sharing-java-7.html&quot;&gt;a later article tailored for Java 7&lt;/a&gt; (five years ago),
    I was able to reproduce the issue and saw it run ten times slower without the performance fix.&lt;/p&gt;

&lt;p&gt;The problem is avoided by &quot;padding&quot; the class for the variables with some unused fields--just as many
    as necessary to cause the objects in memory to break out into their own cache lines.
    Alternatively, the runtime annotation &lt;code&gt;@sun.misc.Contended&lt;/code&gt; can be applied
    to a shared variable to override the JVM's automatic memory layout.&lt;/p&gt;

&lt;h2&gt;Missing Safepoint&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;i&gt;&lt;a href=&quot;http://psy-lob-saw.blogspot.co.za/2015/12/safepoints.html&quot;&gt;Safepoints: Meaning, Side Effects and Overheads&lt;/a&gt;&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;&lt;a href=&quot;https://plumbr.eu/blog/performance-blog/logging-stop-the-world-pauses-in-jvm&quot;&gt;Logging stop-the-world pauses in JVM&lt;/a&gt;&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://groups.google.com/d/msg/mechanical-sympathy/GGByLdAzlPw/cF1_XW1AbpEJ&quot;&gt;Forum post by Gil Tene on safepoints&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A safepoint is a point in a thread's execution that a JVM decides is a safe place
    for the thread to pause when in needs to. Safepoints must be reached for &quot;stop-the-world&quot;
    events such as GC. In this article, it's shown that long pauses in execution can happen
    not because of GC itself, but due to a long time-to-safepoint (TTSP), possibly in preparation for GC.
    I ran the code provided by the article and got the following output.&lt;/p&gt;
&lt;blockquote&gt;
    testNoAllocations&lt;br/&gt;
    testAllocationsOnHeap&lt;br/&gt;
    No allocation took 50208 with result 500000000000&lt;br/&gt;
    Allocations0&lt;br/&gt;
    Allocations1&lt;br/&gt;
    Allocations2&lt;br/&gt;
    ...
&lt;/blockquote&gt;
&lt;p&gt;The &quot;allocations&quot; thread made some progress with its inner loop but ran out of free memory,
    and was forced to pause and wait almost a minute for the other thread to finish,
    negating any benefit that multithreading could have provided.
    In this case the JIT compiler assumed that the no-allocations loop would be fast enough
    that it wouldn't be necessary to add safepoints to it.&lt;/p&gt;

&lt;h2&gt;&quot;Hot method too big&quot;&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;i&gt;&lt;a href=&quot;http://normanmaurer.me/blog/2014/05/15/Inline-all-the-Things/&quot;&gt;Inline all the things&lt;/a&gt;&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;&lt;a href=&quot;http://www.azulsystems.com/blog/cliff/2011-04-04-fixing-the-inlining-problem&quot;&gt;Fixing the Inlining &quot;Problem&quot;&lt;/a&gt;&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-md-12&quot;&gt;
    &lt;img class=&quot;img-responsive pull-left&quot; src=&quot;img/Amazon_Women_in_the_Mood (1).jpg&quot; style=&quot;width: 33.333%; margin-right: 10px&quot;/&gt;
    &lt;p&gt;Running with the JVM options &quot;-XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining&quot;
        shows all of the method inlining performed by the JIT compiler.
        Doing this with a few apps, I've seen the message &quot;hot method too big&quot; from application code,
        major library methods, and even JDK methods.
        It means that the method has been frequently used but the compiler was not able to inline it
        because it exceeds the threshold for inline-able method size defined by JVM arg &quot;MaxInlineSize&quot; or &quot;FreqInlineSize.&quot;&lt;/p&gt;
    &lt;p&gt;Is this a big deal? In any case, it's usually a good idea to split large methods into smaller ones
        for all the nice &quot;-ilities&quot; (maintainability, reusability).&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;
</description>
      <pubDate>Tue, 1 Nov 2016 00:00:00 -0500</pubDate>
      <guid isPermaLink="false">blog/2016/11-01.html</guid>
    </item>
    <item>
      <title>Lucas's Compendium of Odd Java Things | Volume 4: Abstract Methods in Enums</title>
      <link>blog/2016/10-15.html</link>
      <description>
&lt;p&gt;&lt;code&gt;enum&lt;/code&gt;s may have abstract methods, as long as every enum constant implements every abstract method.&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
 enum TrailerParkBoy {

     BUBBLES {
         @Override public int getMoney() {
             return fixShoppingCarts();
         }
     },
     JULIAN {
         @Override public int getMoney() {
             return runCasino() + flipTrailer();
         }
     },
     RICKY {
         @Override public int getMoney() {
             return recycleBottles() - employCoryAndTrevor();
         }
     };

     public abstract int getMoney();
 }
&lt;/pre&gt;
&lt;p&gt;This is useful when every constant is associated with some unique computation, and not just some unique value.
    (In the latter case one may as well define the constants with the values as constructor parameters.)&lt;/p&gt;
&lt;p&gt;With Java 8, there is a way to accomplish the same thing in a more concise way.
    The same operations can be defined by lambdas/method references, which are passed to a constructor
    and invoked in a non-abstract method.&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
 enum TrailerParkBoyWithLambdas {

     BUBBLES(Main::fixShoppingCarts),
     JULIAN(() -&gt; runCasino() + flipTrailer()),
     RICKY(() -&gt; recycleBottles() - employCoryAndTrevor());

     private final Supplier&amp;lt;Integer&amp;gt; moneySupplier;

     TrailerParkBoyWithLambdas(Supplier&amp;lt;Integer&amp;gt; moneySupplier) {
         this.moneySupplier = moneySupplier;
     }

     public int getMoney() {
         return moneySupplier.get();
     }
 }
&lt;/pre&gt;
&lt;p&gt;The lambda technique should exhibit no worse performance thanks to
    &lt;a href=&quot;https://declara.com/collection/49b0b2e6-dc44-49f3-a4f4-69945bc3b280/post/20b1dbc5-fafc-4398-aa89-36372a6a4e43&quot;&gt;call stack optimizations by JIT compilers&lt;/a&gt;.
    Actually, it might be better given that
    &lt;a href=&quot;https://www.infoq.com/articles/Java-8-Lambdas-A-Peek-Under-the-Hood&quot;&gt;lambdas are compiled to static methods&lt;/a&gt;.&lt;/p&gt;
</description>
      <pubDate>Sat, 15 Oct 2016 00:00:00 -0500</pubDate>
      <guid isPermaLink="false">blog/2016/10-15.html</guid>
    </item>
    <item>
      <title>Lucas's Compendium of Odd Java Things | Volume 3: Lambdas Throwing Checked Exceptions</title>
      <link>blog/2016/10-01.html</link>
      <description>
&lt;p&gt;Probably any developer developing in Java 8 will eventually run into the issue of wanting to call a method
    that takes a functional parameter, but wanting to give it one that throws a checked exception.
    For example, IntelliJ will be all like,&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;img/Screen%20Shot%202016-08-31%20at%203.02.31%20PM.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;And then you'll be all like,&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; src=&quot;img/200.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Relax, Titus. First of all, there's really no nice way to pass a lambda that throws a checked exception
    to any of the commonly used methods that take them, such as those provided by Stream.
    You may as well go &quot;back to basics&quot; and use Java 7 syntax. It isn't any less readable.&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
     for (final String s : classNames) {
         Class.forName(s);
     }
&lt;/pre&gt;

&lt;p&gt;However, there are ways to make it work, even if it would have to be monstrously cruel
    to other developers reading your code.
    There is a &lt;a href=&quot;http://stackoverflow.com/questions/18198176/java-8-lambda-function-that-throws-exception&quot;&gt;well-traveled StackOverflow thread addressing this topic.&lt;/a&gt;
    The answer accepted there describes how to use lambdas with exceptions re-thrown as RuntimeExceptions
    (which need not be caught or declared). The point of checked exceptions
    is that you are forced to catch or declare them, thereby mitigating bugs,
    which makes the RuntimeException solution seem kind of self-defeating.
    An interesting idea (the &lt;a href=&quot;http://stackoverflow.com/a/27252163/1907186&quot;&gt;second answer on the thread&lt;/a&gt;)
    is to override the functional method
    with a default one, and add an abstract, non-default method
    (which becomes the one that is implemented by lambdas) that throws something.&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
     @FunctionalInterface
     public interface CheckedConsumer&amp;lt;T&amp;gt; extends Consumer&amp;lt;T&amp;gt; {

         @Override
         default void accept(final T t) {
             try {
                 acceptThrows(t);
             } catch (Exception e) {
                 doThrow(e);
             }
         }

         void acceptThrows(T t) throws Exception;

         @SuppressWarnings(&quot;unchecked&quot;)
         static &amp;lt;E extends Exception&amp;gt; void doThrow(Exception e) throws E {
             throw (E) e;
         }
     }
&lt;/pre&gt;

&lt;p&gt;How does that static doThrow method work, by the way?
    &lt;a href=&quot;http://stackoverflow.com/questions/31316581/a-peculiar-feature-of-exception-type-inference-in-java-8&quot;&gt;StackOverflow nails it again&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It may be noted that the &lt;a href=&quot;https://projectlombok.org/features/SneakyThrows.html&quot;&gt;lombok.SneakyThrows annotation&lt;/a&gt;
    may be used to achieve a similar result. I find lombok really exciting in general because of its contribution to
    conciseness in Java code, but I wouldn't recommend using this annotation for a reason I will explain shortly.&lt;/p&gt;

&lt;p&gt;Oh and also, why not make acceptThrows generic with an exception type parameter, which would make it more flexible
    (i.e., &lt;code&gt;&amp;lt;E extends Exception&amp;gt; void acceptThrows(T t) throws E&lt;/code&gt;)?
    Simply because there is no syntax that would accommodate its use as a lambda, owing to the language spec
    (&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.3&quot;&gt;15.27.3&lt;/a&gt;):&lt;/p&gt;
&lt;blockquote&gt;
    &lt;p&gt;A lambda expression is &lt;i&gt;congruent&lt;/i&gt; with a function type if all of the following are true:&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;The function type has no type parameters.&lt;/li&gt;
        &lt;li&gt;...&lt;/li&gt;
    &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since the CheckedConsumer interface extends Consumer, it can be used to fix the broken code:&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
    Collections.singleton(&quot;abc&quot;).forEach((CheckedConsumer&amp;lt;String&amp;gt;) Class::forName);
&lt;/pre&gt;
&lt;div class=&quot;well&quot;&gt;A quick explanation of the above cast expression: a method reference is treated just like a lambda.
    A cast is an explicit way (context clues being another way) for the compiler to infer the target type
    of a lambda expression. If it were missing, as in the initial example,
    the compiler would infer the target type from the forEach method parameter and
    thus assume &lt;code&gt;Class::forName&lt;/code&gt; should implement Consumer#accept.&lt;/div&gt;

&lt;p&gt;Still, this isn't much better than the technique of rethrowing with RuntimeExceptions because,
    since Iterable#forEach doesn't throw anything, the compiler won't expect the method calling this code
    to throw anything, either. We need it to compile, but for robustness, we still want to require the exception
    to be handled. To this end, you'd have to wrap it with another method that does throw the exceptions
    that other methods should be expected to handle, or that at least throws Exception.&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
     static &amp;lt;T&amp;gt; void forEach(Collection&amp;lt;T&amp;gt; collection, CheckedConsumer&amp;lt;T&amp;gt; consumer) throws Exception {
         collection.forEach(consumer);
     }

     {
         forEach(Collections.singleton(&quot;abc&quot;), Class::forName); // Unhandled exception: java.lang.Exception
                                                                // (which is roughly what we want)
     }
&lt;/pre&gt;

&lt;p&gt;But, this is definitely nicer than the alternative of using a try-catch inside the lambda,
    having it throw RuntimeException, catching it, and conditionally throwing the cause,
    in order to achieve the same functionality:&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
     try {
         classNames.forEach(s -&amp;gt; {
             try {
                 Class.forName(s);
             }
            catch (ClassNotFoundException e) {
                 throw new RuntimeException(e);
             }
         });
     }
     catch (Exception e) {
         if (e.getCause() instanceof ClassNotFoundException) {
             throw (ClassNotFoundException) e.getCause();
         }
         else {
             throw e; // some other Throwable happened
         }
     }
&lt;/pre&gt;

&lt;p&gt;I personally would only ever use the &quot;CheckedConsumer&quot; trick if I had to use a particular
    Exception-throwing lambda in about 1000 different places and it saved me a lot of typing.
    In any case, this illustrates an unfortunate limitation of the Java language.&lt;/p&gt;


</description>
      <pubDate>Sat, 1 Oct 2016 00:00:00 -0500</pubDate>
      <guid isPermaLink="false">blog/2016/10-01.html</guid>
    </item>
    <item>
      <title>Lucas's Compendium of Odd Java Things | Volume 2: Dynamic Implementations</title>
      <link>blog/2016/09-15.html</link>
      <description>
&lt;p&gt;
    In this second installment of the series, I'll provide an overview of a few technologies that enable
    runtime generation of implementation classes and/or proxies.
    You may ask yourself, &quot;why should I care about this low-level stuff?&quot;
    Many frameworks we use daily rely upon runtime classes/proxies to do a number of things:&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;Lazy loading (with Hibernate)&lt;/li&gt;
    &lt;li&gt;Aspects (AspectJ/Spring AOP)&lt;/li&gt;
    &lt;li&gt;Implementation by configuration (for MyBatis mappers, etc.)&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_remote_method_invocation&quot;&gt;Remote Method Invocation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There's a &lt;a href=&quot;http://stackoverflow.com/questions/933993/what-are-dynamic-proxy-classes-and-why-would-i-use-one&quot;&gt;StackOverflow post that covers this as well&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Preface&lt;/h2&gt;
&lt;p&gt;The goals of this overview are&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;to provide examples of usage of a few class generation/proxying facilities,
        such that they all produce the same output but vary in how it's produced; and&lt;/li&gt;
    &lt;li&gt;to provide some rough performance statistics for comparison.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, this overview will not go into the nuts and bolts of JVM bytecode
    (which is largely what these tools abstract away for us).&lt;/p&gt;

&lt;p&gt;Each example will use the following simple classes:&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
     public class Person {

         private final String name;
         private final String position;
         private final LocalDate birthdate;

         public Person(String name, String position, LocalDate birthdate) {
             this.name = name;
             this.position = position;
             this.birthdate = birthdate;
         }

         public String getName() {
             return name;
         }

         public String getPosition() {
             return position;
         }

         public LocalDate getBirthdate() {
             return birthdate;
         }
     }

     public interface PersonService {

         Person getPerson(String name);

         default void removePerson(Person person) {
             System.out.println(&quot;default removePerson&quot;);
         }

         default void updatePerson(Person person) throws Exception {
             System.out.println(&quot;default updatePerson&quot;);
         }
     }

     public abstract class AbstractPersonService implements PersonService {

         private final DataSource dataSource;

         public AbstractPersonService(DataSource dataSource) {
             this.dataSource = dataSource;
         }

         @Override
         public Person getPerson(String name) {
             System.out.println(&quot;getPerson&quot;);

             // ...
             if (&quot;Jim Lahey&quot;.equals(name)) {
                 return new Person(&quot;Jim Lahey&quot;, &quot;Trailer Park Supervisor&quot;, LocalDate.of(1946, 4, 12));
             }
             else {
                 return null;
             }
         }

         @Override
         public abstract void updatePerson(Person person);
     }
&lt;/pre&gt;

&lt;p&gt;These classes provide basis for a few constraints:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;The generated class will be a non-abstract implementation of PersonService;&lt;/li&gt;
    &lt;li&gt;AbstractPersonService#getPerson(String) will not be overridden;&lt;/li&gt;
    &lt;li&gt;PersonService#removePerson(Person) will not be overridden; and&lt;/li&gt;
    &lt;li&gt;AbstractPersonService#updatePerson(Person) will be implemented.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And, in accordance with these constraints, each program will produce the following output
    (5000 times, actually, for rudimentary performance testing):&lt;/p&gt;
&lt;blockquote&gt;
    intercepted... getPerson&lt;br/&gt;
    intercepted... proxied updatePerson&lt;br/&gt;
    intercepted... default removePerson&lt;br/&gt;
&lt;/blockquote&gt;

&lt;p&gt;Further, each example will make use of these:&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
     static final int TIMES = 5000;

     static void intercepted() {
         System.out.print(&quot;intercepted... &quot;);
     }

     private static void usePersonService(PersonService personService) {

         Person person = personService.getPerson(&quot;Jim Lahey&quot;);
         Assert.assertEquals(&quot;Jim Lahey&quot;, person.getName());

         try {
             personService.updatePerson(person);
         }
         catch (Exception e) {
             throw new RuntimeException(e);
         }

         personService.removePerson(person);
     }

     static void repeat(Procedure f) {
         try {
             // run once to work out initial class generation when applicable
             f.invoke();

             final long start = System.currentTimeMillis();
             for (int i = 0; i &lt; TIMES; i++) {
                 f.invoke();
             }
             System.out.println(&quot;finished in &quot; + (System.currentTimeMillis() - start) + &quot; ms&quot;);
         }
         catch (Exception e) {
             throw new RuntimeException(e);
         }
     }

     @FunctionalInterface
     private interface Procedure {
         void invoke() throws Exception;
     }
&lt;/pre&gt;
&lt;p&gt;With this premise established, here are some examples using a few libraries:
    the JDK,
    &lt;a href=&quot;https://github.com/cglib/cglib/wiki&quot;&gt;cglib&lt;/a&gt;, and
    &lt;a href=&quot;http://jboss-javassist.github.io/javassist/&quot;&gt;Javassist&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;java.lang.reflect.Proxy&lt;/h2&gt;
&lt;p&gt;You might have guessed that no libraries need be pulled in for this.
    JDK proxying is limited to implementing interfaces, which means I actually have to implement
    AbstractPersonService &quot;normally&quot; like some kind of savage.
    This implementation will be a delegate for an invocation handler.
    An invocation handler is a typical proxying mechanism for &quot;intercepting&quot; calls to methods and
    handling the calls however one feels like--within reason. One cannot, for example,
    have an invocation handler return a type that isn't assignable to the original method's
    return type.&lt;/p&gt;

&lt;pre class=&quot;brush: java&quot;&gt;
     final PersonService unproxiedService = new AbstractPersonService(null) {
         @Override
         public void updatePerson(Person person) {
             throw new UnsupportedOperationException();
         }
     };

     final Collection&amp;lt;Method&amp;gt; abstractMethods = Arrays.stream(AbstractPersonService.class.getMethods())
             .filter(abstractClassMethod -&gt; Modifier.isAbstract(abstractClassMethod.getModifiers()))
             .collect(Collectors.toList());
     final java.lang.reflect.InvocationHandler handler = new java.lang.reflect.InvocationHandler() {
         @Override
         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

             intercepted();

             // if the method on the abstract class is abstract, then handle it here
             final Method unimplementedMethod = abstractMethods.stream()
                     .filter(abstractClassMethod -&gt;
                             Objects.equals(abstractClassMethod.getName(), method.getName()) &amp;&amp;
                             Arrays.equals(abstractClassMethod.getParameterTypes(), method.getParameterTypes()))
                     .findFirst()
                     .orElse(null);
             if (unimplementedMethod != null) {
                 System.out.println(&quot;proxied &quot; + method.getName());
                 return null;
             }
             else {
                 return method.invoke(unproxiedService, args);
             }
         }
     };

     final Class&amp;lt;PersonService&amp;gt; implClass = (Class&amp;lt;PersonService&amp;gt;) Proxy.getProxyClass(
             Thread.currentThread().getContextClassLoader(), PersonService.class);
     try {
         final Constructor&amp;lt;PersonService&amp;gt; constructor = implClass.getConstructor(
                 java.lang.reflect.InvocationHandler.class);
         repeat(() -&gt; {
             final PersonService personService = constructor.newInstance(handler);
             usePersonService(personService);
         });
     }
     catch (Exception e) {
         throw new RuntimeException(e);
     }
&lt;/pre&gt;
&lt;p&gt;Doesn't it seem a little pointless to have created a Proxy when I could have just
    fully implemented &lt;code&gt;unproxiedService&lt;/code&gt;? Not to say that Proxy is not extremely useful,
    but for this use case, it arguably is more trouble than it's worth.
    cglib is an attractive alternative as it provides runtime subclassing.&lt;/p&gt;

&lt;h2&gt;cglib&lt;/h2&gt;
&lt;p&gt;This example uses this Maven dependency:&lt;/p&gt;
&lt;pre class=&quot;brush: xml&quot;&gt;
    &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;cglib&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;cglib&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;3.2.4&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;
&lt;p&gt;Spring and Guice make use of cglib. It's a mid-level tool, as opposed to
    the high-level AspectJ and the low-level &lt;a href=&quot;https://en.wikipedia.org/wiki/ObjectWeb_ASM&quot;&gt;ASM&lt;/a&gt;;
    cglib itself uses ASM for bytecode manipulation.&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
     final Enhancer enhancer = new Enhancer();
     // enhancer.setInterfaces(new Class[] { PersonService.class }); // this is inferred
     enhancer.setSuperclass(AbstractPersonService.class);
     enhancer.setInterceptDuringConstruction(false); // optimization

     net.sf.cglib.proxy.InvocationHandler abstractCallback = (obj, method, args) -&amp;gt; {

         intercepted();

         System.out.println(&quot;proxied &quot; + method.getName());
         return null;
     };

     net.sf.cglib.proxy.MethodInterceptor otherCallback = (obj, method, args, proxy) -&amp;gt; {

         intercepted();

         // invoke the intercepted method on the enhanced object (an AbstractPersonService)
         return proxy.invokeSuper(obj, args);
     };

     CallbackHelper callbackHelper = new CallbackHelper(
             AbstractPersonService.class,
             new Class[] { PersonService.class }) {

         @Override
         protected Object getCallback(Method method) {

             // if the method on the abstract class is abstract, then handle it here
             if (Modifier.isAbstract(method.getModifiers())) {
                 return abstractCallback;
             }
             else {
                 return otherCallback;
             }
         }
     };

     enhancer.setCallbackFilter(callbackHelper);
     enhancer.setCallbacks(callbackHelper.getCallbacks());
     Class[] types = new Class[] { DataSource.class };
     Object[] args = new Object[] { null };
     repeat(() -&amp;gt; {
         final PersonService personService = (PersonService) enhancer.create(types, args);
         usePersonService(personService);
     });
&lt;/pre&gt;

&lt;h2&gt;Javassist&lt;/h2&gt;
&lt;p&gt;This example uses this Maven dependency:&lt;/p&gt;
&lt;pre class=&quot;brush: xml&quot;&gt;
    &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.javassist&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;javassist&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;3.20.0-GA&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;
&lt;p&gt;This is where things start to get weird.&lt;/p&gt;
&lt;p&gt;This is not really a dynamic proxying tool, but is primarily a bytecode manipulation tool
    with kind of a mid-level interface.&lt;/p&gt;
&lt;p&gt;You may notice that I'm frequently catching exceptions and rethrowing them as RuntimeException;
    this is for elucidation of what sorts of Throwables these things throw.&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
     javassist.ClassPool classPool = javassist.ClassPool.getDefault();
     final CtClass abstractCtClass, iCtClass, personCtClass, implCtClass;
     final CtMethod updateCtMethod;
     try {
         abstractCtClass = classPool.get(AbstractPersonService.class.getName());
         iCtClass = classPool.get(PersonService.class.getName());
         personCtClass = classPool.get(Person.class.getName());
         implCtClass = classPool.makeClass(
                 AbstractPersonService.class.getPackage().getName() + &quot;.&quot; + &quot;PersonServiceImpl&quot;,
                 abstractCtClass);

         updateCtMethod = abstractCtClass.getMethod(
                 &quot;updatePerson&quot;,
                 Descriptor.ofMethod(CtClass.voidType, new CtClass[] { personCtClass }));
     }
     catch (NotFoundException e) {
         throw new RuntimeException(e);
     }


     final CtMethod newUpdateMethod;
     try {
         // altering updateMethod would alter the method on the abstract CtClass! so make a copy
         newUpdateMethod = CtNewMethod.copy(updateCtMethod, implCtClass, null);
         newUpdateMethod.setBody(&quot;{ System.out.println(\&quot;proxied &quot; + updateCtMethod.getName() + &quot;\&quot;); }&quot;);
         // note: addMethod must be used after setting the CtMethod body.
         // otherwise it would be added as an abstract method, which would turn the CtClass into an abstract class.
         implCtClass.addMethod(newUpdateMethod);

         // now add the intercept calls
         CtMethod[] methods = implCtClass.getMethods();
         for (CtMethod method : methods) {
             try {
                 // if getting the method on the interface doesn't fail,
                 // then copy the method, insert the intercept call, and add the new method
                 iCtClass.getDeclaredMethod(method.getName(), method.getParameterTypes());

                 CtMethod newMethod = CtNewMethod.copy(method, implCtClass, null);
                 newMethod.insertBefore(&quot;{ &quot; + this.getClass().getName() + &quot;.intercepted(); }&quot;);
                 if (method.getDeclaringClass() == implCtClass) {
                    // then we're decorating the previously added updateMethod
                     implCtClass.removeMethod(method);
                 }

                 implCtClass.addMethod(newMethod);
             }
             catch (NotFoundException e) {
                 e = e; // fall through
             }
         }
     }
     catch (CannotCompileException e) {
         throw new RuntimeException(e);
     }

     final Class&amp;lt;? extends AbstractPersonService&amp;gt; implClass;
     try {
         implClass = classPool.toClass(implCtClass);
     }
     catch (CannotCompileException e) {
         throw new RuntimeException(e);
     }

     try {
         // this works because creating the impl class automatically creates a constructor that calls super
         final Constructor&amp;lt;? extends AbstractPersonService&amp;gt; constructor =
                 implClass.getDeclaredConstructor(DataSource.class);
         repeat(() -&amp;gt; {
             final PersonService personService = constructor.newInstance((DataSource) null);
             usePersonService(personService);
         });
     }
     catch (Exception e) {
         throw new RuntimeException(e);
     }
&lt;/pre&gt;

&lt;h2&gt;ByteBuddy (a brief introduction)&lt;/h2&gt;
&lt;p&gt;I didn't create an example using &lt;a href=&quot;http://bytebuddy.net/&quot;&gt;ByteBuddy&lt;/a&gt; but in this discussion it is only fair to at least point out its existence.
    ByteBuddy has supplanted Javassist in version 2 of mocking library Mockito.
    It fills a niche similar to that of cglib and Javassist.
    It seems to offer a friendlier API than any of the previously mentioned tools.&lt;/p&gt;

&lt;h2&gt;Performance&lt;/h2&gt;
&lt;p&gt;I managed to isolate the function passed to the repeat method in all the examples to a simple sequence:
    first, instantiate the generated ProxyService class, and second, call usePersonService on the instance.
    Otherwise, I attempted to optimize each program as much as possible.
    This table shows the time it took for each of these functions to be run 5000 times.
    This was run on an early-2013 Macbook Pro.&lt;/p&gt;
&lt;table class=&quot;table&quot;&gt;
    &lt;tr&gt;&lt;th&gt;Library&lt;/th&gt;&lt;th&gt;Time (ms)&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;JDK&lt;/td&gt;&lt;td&gt;254&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;cglib&lt;/td&gt;&lt;td&gt;261&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Javassist&lt;/td&gt;&lt;td&gt;136&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;Javassist wins! I hypothesize that this is because the generated Javassist class does not involve handlers
    that calls must be passed through, but is rather a new class as would be produced by compiling
    a written implementation. But, get a load of this line:&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
    newMethod.insertBefore(&quot;{ &quot; + this.getClass().getName() + &quot;.intercepted(); }&quot;);
&lt;/pre&gt;
&lt;p&gt;This is brittle and not something a fancy IDE will be able to include in analysis.
    I would avoid generating code this way unless it's internal to a library.&lt;/p&gt;

&lt;h2&gt;Further reading&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;spring.io: &lt;a href=&quot;https://spring.io/blog/2007/07/19/debunking-myths-proxies-impact-performance/&quot;&gt;Debunking myths: proxies impact performance&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
      <pubDate>Thu, 15 Sep 2016 00:00:00 -0500</pubDate>
      <guid isPermaLink="false">blog/2016/09-15.html</guid>
    </item>
    <item>
      <title>Lucas's Compendium of Odd Java Things | Volume 1: Type Intersections</title>
      <link>blog/2016/09-01.html</link>
      <description>
&lt;p&gt;This is the first of a series of blogs focused on Java language &amp; Java virtual machine features that are rarely
    used, and might even make you wonder what Sun or Oracle was smoking when they came up with it.
    I invite suggestions of topics for this blog as I love to explore obscure aspects of programming,
    which probably makes me a gigantic hipster--all I need is a trucker hat with an espresso cup logo on it.
    You know, I liked lambda expressions before they got all &quot;mainstream.&quot;&lt;/p&gt;

&lt;p&gt;The topic for today is intersection types
    (see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se6/html/typesValues.html#123179&quot;&gt;JLS Third Edition, 4.9, &quot;Intersection Types&quot;&lt;/a&gt;).
    To illustrate, say you have the following class definitions,
    as well as a method that needs to be able to take them as parameters.&lt;/p&gt;

&lt;pre class=&quot;brush: java&quot;&gt;
    @FunctionalInterface
    interface Puntable {
        double puntability();
    }

    enum Animal implements Puntable {
        HORSE(0.05),
        CAT(60);

        private final double puntability;

        Animal(final double puntability) {
            this.puntability = puntability;
        }

        @Override
        public double puntability() {
            return puntability;
        }
    }

    enum Ball implements Puntable {
        DANCE_PARTY_FOR_FANCY_PEOPLE(0),
        BASKETBALL(30),
        FOOTBALL(60.5);

        private final double puntability;

        Ball(final double puntability) {
            this.puntability = puntability;
        }

        @Override
        public double puntability() {
            return puntability;
        }
    }

    static &amp;lt;???&amp;gt; ??? mostPuntable(??? t1, ??? t2) {

        if (t1.puntability() == t2.puntability()) {
            return t1.ordinal() &gt; t2.ordinal() ? t1 : t1.ordinal() &lt; t2.ordinal() ? t2 : t1;
        }
        else {
            return t1.puntability() &gt; t2.puntability() ? t1 : t2;
        }
    }
&lt;/pre&gt;

&lt;p&gt;What can we replace the &quot;???&quot; with? The method needs to be able to use methods on both Enum and Puntable;
    we also want to avoid explicit casting.
    We don't have types that both implement Puntable and extend these Enums--the latter of which being impossible
    since an Enum can't be subclassed. The solution is to use an intersection of these two types as such:&lt;/p&gt;

&lt;pre class=&quot;brush: java&quot;&gt;
    static &amp;lt;T extends Enum&amp;lt;T&amp;gt; &amp; Puntable&amp;gt; T mostPuntable(T t1, T t2) { ...
&lt;/pre&gt;

&lt;p&gt;This syntax was introduced around Java SE5. It provides the ability to use multiple bounds
    for a parameterized type when you can't or won't be bothered to use a type that encompasses all of those bounds.
    Here is another example:&lt;/p&gt;

&lt;pre class=&quot;brush: java&quot;&gt;
    static &amp;lt;T, U extends List&amp;lt;T&amp;gt; &amp; RandomAccess&amp;gt; void manipulateList(U list) {
        // something where random access is important,
        // but it doesn't have to be a java.util.ArrayList
    }

    {
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;taco1&quot;, &quot;taco2&quot;);
        manipulateList(list); // &lt;-- Nope. This will not compile.
    }
&lt;/pre&gt;

&lt;p&gt;Another way to use them is casting a lambda or method reference as an intersection type.
    This is restricted to cases where one of the bounds is a functional interface and the other bounds
    are either method-less or share the same method signature.
    One real-world usage of this is when you want to
    &lt;a href=&quot;http://stackoverflow.com/questions/22807912/how-to-serialize-a-lambda&quot;&gt;make a lambda both Serializable and something else&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&quot;brush: java&quot;&gt;
    Puntable p = (Puntable &amp; Serializable) System::currentTimeMillis;
    System.out.println(p.puntability()); // e.g. 1.471563193067E12
&lt;/pre&gt;

&lt;p&gt;Note that you can use more than two bounds in a type intersection.&lt;/p&gt;
</description>
      <pubDate>Thu, 1 Sep 2016 00:00:00 -0500</pubDate>
      <guid isPermaLink="false">blog/2016/09-01.html</guid>
    </item>
  </channel>
</rss>